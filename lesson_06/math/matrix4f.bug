require "matrix"

class Matrix4f
  property m : Matrix(Float32)

  def initialize
    @m = Matrix(Float32).new(4, 4)
  end

  def initialize(matrix : Matrix(Float32))
    dimensions = matrix.dimensions
    raise Matrix::DimensionMismatch.new unless dimensions[0] == 4 && dimensions[1] == 4
    @m = matrix
  end

  def values()
    return @m.clone
  end

  def []=(row : Int, column : Int, value : Float32)
    @m.[]=(row, column, value)
  end

  # Retrieves the element at the given row and column indexes.
  def [](row : Int, column : Int)
    @m.[](row, column)
  end

  def as_array
    @m.to_a
  end

  def init_identity
    @m = Matrix(Float32).new(4, 4) do |i, r, c|
      r == c ? 1f32 : 0f32
    end
    self
  end

  def init_perspective(fov : Float32, aspect_ratio : Float32, z_near : Float32, z_far : Float32)

    # old code #
    # old code # center of window
    # old code #
    # old code tan_half_fov = Math.tan(fov / 2)
    # old code z_range = z_near - z_far
    # old code
    # old code # start with identity matrix
    # old code @m = Matrix(Float32).new(4, 4) do |i, r, c|
    # old code   r == c ? 1f32 : 0f32
    # old code end
    # old code
    # old code @m.[]=(0, 0, 1.0f32 / (tan_half_fov * aspect_ratio))
    # old code @m.[]=(1, 1, 1.0f32 / tan_half_fov)
    # old code @m.[]=(2, 2, (-z_near - z_far) / z_range)
    # old code @m.[]=(2, 3, -2.0f32 * z_far * z_near / z_range)
    # old code @m.[]=(3, 2, 1.0f32)
    # old code @m.[]=(3, 3, 0.0f32)
    # old code
    # old code self

    # test tan_half_fov = Math.tan(fov / 2)
    # test
    # test zm           = z_far - z_near
    # test zp           = z_far + z_near
    # test
    # test # start with identity matrix
    # test @m = Matrix(Float32).new(4, 4) do |i, r, c|
    # test   r == c ? 1f32 : 0f32
    # test end
    # test
    # test @m.[]=(0, 0, 1.0f32 / (tan_half_fov * aspect_ratio))
    # test @m.[]=(1, 1, 1.0f32 / tan_half_fov)
    # test
    # test @m.[]=(2, 2, (-z_near - z_far) / zm)
    # test #@m.[]=(2, 2, -zp/zm)
    # test
    # test @m.[]=(2, 3, 2.0f32 * z_far * z_near / zm)
    # test #@m.[]=(2, 3, -2.0f32 * z_far * z_near / zm)
    # test
    # test @m.[]=(3, 2, 1.0f32)
    # test #@m.[]=(3, 2, -1.0f32)
    # test @m.[]=(3, 3,  0.0f32)

    @m = Matrix(Float32).new(4, 4) do |i, r, c|
      r == c ? 1f32 : 0f32
    end

    scale = 1.0/Math.tan(fov * 0.5 * Math::PI/180.0)
    zm    = z_far - z_near
    zp    = z_far + z_near

    @m.[]=(0, 0, scale.to_f32)
    @m.[]=(1, 1, scale.to_f32)
    @m.[]=(2, 2, -z_far/(z_far - z_near) )
    @m.[]=(3, 2, -z_far * z_near/(z_far - z_near) )
    @m.[]=(2, 3, -1.0f32)
    @m.[]=(3, 3,  0.0f32)
    self
  end

  def init_orthographic(left : Float32, right : Float32, bottom : Float32, top : Float32, near : Float32, far : Float32) : Matrix4f
    width = right - left
    height = top - bottom
    depth = far - near

    # start with identity matrix
    @m = Matrix(Float32).new(4, 4) do |i, r, c|
      r == c ? 1f32 : 0f32
    end

    @m.[]=(0, 0, 2/width); @m.[]=(0, 3, -(right + left)/width)
    @m.[]=(1, 1, 2/height); @m.[]=(1, 3, -(top + bottom)/height)
    @m.[]=(2, 2, -2/depth); @m.[]=(2, 3, -(far + near)/depth)

    self
  end

  def init_rotation(forward : Vector3f, up : Vector3f)
    f = forward.to_normalized
    r = up.to_normalized.cross(f)
    u = f.cross(r)

    return self.init_rotation(f, u, r)
  end

  def init_rotation(forward : Vector3f, up : Vector3f, right : Vector3f)
    f = forward
    r = right
    u = up

    # start with identity matrix
    @m = Matrix(Float32).new(4, 4) do |i, r, c|
      r == c ? 1f32 : 0f32
    end

    @m.[]=(0, 0, r.x); @m.[]=(0, 1, r.y); @m.[]=(0, 2, r.z)
    @m.[]=(1, 0, u.x); @m.[]=(1, 1, u.y); @m.[]=(1, 2, u.z)
    @m.[]=(2, 0, f.x); @m.[]=(2, 1, f.y); @m.[]=(2, 2, f.z)
    self
  end

  # Turns the matrix into a translation matrix
  def init_translation(x : Float32, y : Float32, z : Float32)
    # start with identity matrix
    @m = Matrix(Float32).new(4, 4) do |i, r, c|
      r == c ? 1f32 : 0f32
    end
    @m.[]=(0, 3, x)
    @m.[]=(1, 3, y)
    @m.[]=(2, 3, z)
    self
  end

  def init_scale(x : Float32, y : Float32, z : Float32)
    # start with identity matrix
    @m = Matrix(Float32).new(4, 4) do |i, r, c|
      r == c ? 1f32 : 0f32
    end
    @m.[]=(0, 0, x)
    @m.[]=(1, 1, y)
    @m.[]=(2, 2, z)
    self
  end

  # converts degrees to radians
  def to_rad(degree : Float32) : Float32
    return degree / 180.0f32 * Math::PI
  end

  def init_rotation(x : Float32, y : Float32, z : Float32)
    # start with identity matricies
    rx = Matrix(Float32).new(4, 4) do |i, r, c|
      r == c ? 1f32 : 0f32
    end
    ry = Matrix(Float32).new(4, 4) do |i, r, c|
      r == c ? 1f32 : 0f32
    end
    rz = Matrix(Float32).new(4, 4) do |i, r, c|
      r == c ? 1f32 : 0f32
    end

    xrad = to_rad(x)
    yrad = to_rad(y)
    zrad = to_rad(z)

    rz.[]=(0, 0, Math.cos(zrad)); rz.[]=(0, 1, -Math.sin(zrad))
    rz.[]=(1, 0, Math.sin(zrad)); rz.[]=(1, 1, Math.cos(zrad))

    rx.[]=(1, 1, Math.cos(xrad)); rx.[]=(1, 2, -Math.sin(xrad))
    rx.[]=(2, 1, Math.sin(xrad)); rx.[]=(2, 2, Math.cos(xrad))
    ry.[]=(0, 0, Math.cos(yrad)); ry.[]=(0, 2, -Math.sin(yrad))
    ry.[]=(2, 0, Math.sin(yrad)); ry.[]=(2, 2, Math.cos(yrad))
    @m = rx * ry * rz
    self
  end

  def transform(r : Vector3f) : Vector3f
    return Vector3f.new(
      @m[0, 0] * r.x + @m[0, 1] * r.y + @m[0, 2] * r.z + @m[0, 3],
      @m[1, 0] * r.x + @m[1, 1] * r.y + @m[1, 2] * r.z + @m[1, 3],
      @m[2, 0] * r.x + @m[2, 1] * r.y + @m[2, 2] * r.z + @m[2, 3]
    )
  end

  def *(other : Matrix4f)
    result = @m * other.m
    return Matrix4f.new(result)
  end

  def +(other : Matrix4f)
    result = @m + other.m
    return Matrix4f.new(result)
  end

  def to_s(io : IO)
    @m.to_s(io)
  end

  def self.create_transformation_matrix(position : Vector3f, rotation : Vector3f, scale : Vector3f) : Matrix4f
    matrix = Matrix4f.new
    translate_matrix = matrix.init_translation(position.x, position.y, position.z)
    puts "t"
    puts translate_matrix

    scale_matrix     = matrix.init_scale(scale.x, scale.y, scale.z)
    puts "s"
    puts scale_matrix

    rotation_matrix  = matrix.init_rotation(rotation.x,rotation.y,rotation.z)
    puts "r"
    puts rotation_matrix

    puts "t * s"
    puts translate_matrix * scale_matrix
    r = translate_matrix * scale_matrix * rotation_matrix
    return r
  end

end
