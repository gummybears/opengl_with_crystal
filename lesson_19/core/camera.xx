require "./math/**"

MIN_ZOOM  = 1f32
MAX_ZOOM  = 100f32
MIN_PITCH = 0f32
MAX_PITCH = 89.999f32

class Camera
  property position : GLM::Vector3
  property pitch    : Float32
  property yaw      : Float32
  property roll     : Float32
  property player   : Player
  property distance_from_player : Float32 = 50.0f32
  property angle_around_player  : Float32 = 0.0f32

  property prev_mouse_position  : GLM::Vector2

  #def initialize(position : GLM::Vector3, pitch : Float32, yaw : Float32, roll : Float32)
  #   @position = position
  #   @pitch    = pitch
  #   @yaw      = yaw
  #   @roll     = roll
  # end
  #
  # def initialize(position : GLM::Vector3)
  #   @position = position
  #   @pitch    = 0.0f32
  #   @yaw      = 0.0f32
  #   @roll     = 0.0f32
  # end
  #
  # def initialize()
  #   @position = GLM::Vector3.new(0f32,0f32,0f32)
  #   @pitch    = 0.0f32
  #   @yaw      = 0.0f32
  #   @roll     = 0.0f32
  # end


  def initialize(player : Player)
    @position = GLM::Vector3.new(0f32,0f32,0f32)
    @pitch    = 20.0f32
    @yaw      = 0.0f32
    @roll     = 0.0f32
    @player   = player
    @prev_mouse_position = GLM::Vector2.new(0f32,0f32)

    horizontal_distance = calculate_horizontal_distance()
    vertical_distance   = calculate_vertical_distance()

    @position = calculate_camera_position(horizontal_distance,vertical_distance)

  end

  def move(display : Display)

    @prev_mouse_position = GLM::Vector2.new(display.window.cursor.position[:x].to_f32,display.window.cursor.position[:y].to_f32)

    calculate_zoom(display)
    calculate_pitch(display)
    calculate_angle_around_player(display)

    horizontal_distance = calculate_horizontal_distance()
    vertical_distance   = calculate_vertical_distance()

    #puts "horz distance #{horizontal_distance} vert distance #{vertical_distance}"

    @position = calculate_camera_position(horizontal_distance,vertical_distance)

    # calculate yaw angle
    @yaw = 180.0f32 - (@player.rotY - @angle_around_player)

    #puts "camera position #{@position.to_s}"

  end

  def calculate_camera_position(horizontal_distance : Float32, vertical_distance : Float32) : GLM::Vector3

    theta      = @player.rotY + @angle_around_player
    offset_x   = horizontal_distance + Math.sin(GLM.radians(theta))
    offset_z   = horizontal_distance + Math.cos(GLM.radians(theta))

    position.x = @player.position.x - offset_x
    position.y = @player.position.y + vertical_distance
    position.z = @player.position.z - offset_z

    return position
  end

  def calculate_horizontal_distance()
    r = @distance_from_player * Math.cos(GLM.radians(@pitch))
    return r
  end

  def calculate_vertical_distance()
    r = @distance_from_player * Math.sin(GLM.radians(@pitch))
    return r
  end

  def calculate_zoom(display : Display)

    offset     = display.scroll_offset
    zoom_level = offset.y.to_f32 * 0.02f32

    @distance_from_player = @distance_from_player - zoom_level
    if @distance_from_player < MIN_ZOOM
      @distance_from_player = MIN_ZOOM
    end

    if @distance_from_player > MAX_ZOOM
      @distance_from_player = MAX_ZOOM
    end

  end

  #
  # pitch is calculated when user presses right mouse button
  #
  def calculate_pitch(display : Display)

    if display.mouse_right == 1
      pitch_change = display.mouse_dy #* 0.1f32
      @pitch = @pitch + pitch_change
      #@pitch = @pitch - pitch_change
    end

    if @pitch < MIN_PITCH
      @pitch = MIN_PITCH
    end

    if @pitch > MAX_PITCH
      @pitch = MAX_PITCH
    end
  end

  #
  # angle around player is calculated when user presses left mouse button
  #
  def calculate_angle_around_player(display : Display)

    if display.mouse_left == 1
      angle_change = display.mouse_dx #* 0.3f32
      @angle_around_player = @angle_around_player - angle_change
    end
  end
end
